<h1 align='center'>Bit - Array</h1>

## Problem Statement

**Problem URL :** [Bit Array](https://www.hackerrank.com/challenges/bitset-1/problem?isFullScreen=true)

![image](https://github.com/user-attachments/assets/c731900b-3ab2-45ec-bc10-81e3a983686d)

## Problem Solution
```cpp
#include <iostream>
#include <algorithm>
#include <unordered_set>
using namespace std;


int main() {
    int N, S, P, Q;
    int mod = (1 << 31);
    
    cin>> N >> S >> P >> Q;
    
    int tortoise = S % mod;
    int here = tortoise;
    
    int count = 0;
    
    while(count < N){
        count++;
        tortoise = (tortoise * P + Q) % mod;
        
        here = (here * P + Q) % mod;
        here = (here * P + Q) % mod;
        
        if(here == tortoise) break;
    }
    cout<< count;
    return 0;
}
```

## Problem Solution Explanation

This code is an implementation of Floyd's Cycle Detection Algorithm (also known as the Tortoise and Hare algorithm). The algorithm is used here to detect cycles in a sequence generated by a linear congruential generator (LCG), which is a method for generating a sequence of pseudo-random numbers.


1. **Initial Setup:**
   ```cpp
   int N, S, P, Q;
   int mod = (1 << 31);
   cin >> N >> S >> P >> Q;
   ```
   - `N`, `S`, `P`, `Q` are the parameters of the problem.
   - `mod` is set to \( 2^{31} \) (which is \( 2147483648 \)) and is used to ensure that the values stay within the 31-bit unsigned integer range.

2. **Initialization:**
   ```cpp
   int tortoise = S % mod;
   int here = tortoise;
   int count = 0;
   ```
   - `tortoise` is initialized to the starting value `S`, modulo `mod` to keep it within the range.
   - `here` is also initialized to the same value as `tortoise`.
   - `count` is initialized to 0, and it will be used to count the number of distinct elements until a cycle is detected or the sequence reaches `N`.

3. **Cycle Detection Loop:**
   ```cpp
   while(count < N){
       count++;
       tortoise = (tortoise * P + Q) % mod;
       
       here = (here * P + Q) % mod;
       here = (here * P + Q) % mod;
       
       if(here == tortoise) break;
   }
   cout<< count;
   ```
   - **Iteration Count:** The loop runs until `count` reaches `N` or a cycle is detected.
   - **Updating `tortoise`:** In each iteration, `tortoise` is updated by generating the next number in the sequence using the formula: `tortoise = (tortoise * P + Q) % mod`.
   - **Updating `here`:** The `here` variable is moved twice as fast as `tortoise`. It is updated twice in each iteration to simulate the "hare" moving ahead of the "tortoise."
   - **Cycle Detection:** If `here` ever equals `tortoise`, it means a cycle is detected, and the loop breaks.

4. **Output:**
   ```cpp
   cout<< count;
   ```
   - The code prints the value of `count`, which represents the number of distinct values generated before a cycle was detected or before `N` iterations were completed.

### What the Code Does

- **Purpose:** This code simulates the generation of a sequence of numbers using a linear congruential generator (LCG) and detects if there is a cycle in the sequence.
- **Cycle Detection:** The `tortoise` and `here` technique is used to detect if the sequence starts repeating (forming a cycle).
- **Count Output:** The output `count` is the number of distinct elements that can be generated before the sequence starts to repeat or before reaching `N` iterations.

### Example:

- Suppose `N = 10`, `S = 1`, `P = 2`, and `Q = 3`.
- The sequence would generate values based on the formula `X[i] = (X[i-1] * P + Q) % mod`, where `X[0] = S`.
- The loop will count how many unique values are generated before a cycle is detected or until `N` values are generated.
- If a cycle is detected, it stops early, otherwise, it will count up to `N`.

The key idea is that instead of storing all generated values (which could be computationally expensive), the code uses cycle detection to efficiently determine the length of the sequence before repetition starts.
